import { SecretType } from '../models/SecretType';
import { Wallet, WalletType } from '../models/wallet/Wallet';
import { Profile } from '../models/profile/Profile';
import { WalletBalance } from '../models/wallet/WalletBalance';
import { TokenBalance } from '../models/wallet/TokenBalance';
import { NFT, WalletItems } from '../models/wallet/NFT';
import { TransactionRequest } from '..';
import { TxStatus } from '../models/transaction/TxStatus';
import { ContractReadRequest } from '../models/contract/ContractReadRequest';
import { ContractReadResult } from '../models/contract/ContractReadResult';
export declare class Api {
    private http;
    constructor(baseURL: string, tokenProvider?: any);
    getAvailableSecretTypes: () => Promise<SecretType[]>;
    getWallets: (params?: {
        secretType?: SecretType | undefined;
        walletType?: WalletType | undefined;
        includeBalance?: boolean | undefined;
    } | undefined) => Promise<Wallet[]>;
    getWallet: (walletId: string) => Promise<Wallet>;
    getBalance: (walletId: string) => Promise<WalletBalance>;
    getBalanceByAddress: (secretType: SecretType, walletAddress: string) => Promise<WalletBalance>;
    getTokenBalances: (walletId: string) => Promise<TokenBalance[]>;
    getTokenBalancesByAddress: (secretType: SecretType, walletAddress: string) => Promise<TokenBalance[]>;
    getTokenBalance: (walletId: string, tokenAddress: string) => Promise<TokenBalance>;
    getTokenBalanceByAddress: (secretType: SecretType, walletAddress: string, tokenAddress: string) => Promise<TokenBalance>;
    getNonfungibles: (walletId: string) => Promise<NFT[]>;
    getNonfungiblesByAddress: (secretType: SecretType, walletAddress: string) => Promise<NFT[]>;
    getAllNonfungibles: (secretTypes?: SecretType[] | undefined) => Promise<WalletItems[]>;
    unlink: (walletId: string) => Promise<void>;
    getProfile: () => Promise<Profile>;
    private processResponse;
    getPendingTransactions: () => Promise<TransactionRequest[]>;
    deleteTransaction: (transactionId: string) => Promise<any>;
    getTransactionStatus: (transactionHash: string, secretType: SecretType) => Promise<RestApiResponseTxStatus>;
    readContract: (contractReadRequest: ContractReadRequest) => Promise<ContractReadResult>;
}
export interface RestApiResponseTxStatus {
    hash: string;
    status: TxStatus;
    confirmations: number;
    blockHash: string;
    blockNumber: number;
    hasReachedFinality: boolean;
}
export interface RestApiResponseError {
    code: string;
    message: string;
}
export interface RestApiResponse<T> {
    success: boolean;
    errors: RestApiResponseError[];
    result: T;
}
