import { PopupResult } from './PopupResult';
import { PopupWindow } from './PopupWindow';
import { EventTypes } from '../types/EventTypes';
export default abstract class Popup {
    private static popupIntervals;
    private static clearPopupIntervals;
    protected popupMountedListener?: (message: MessageEvent) => any;
    protected finishedListener?: (message: MessageEvent) => any;
    protected onPopupMountedQueue: Array<() => void>;
    protected isPopupMounted: boolean;
    protected useOverlay: boolean;
    protected popupWindow: PopupWindow;
    protected correlationID: string;
    protected readonly bearerTokenProvider: () => string;
    protected abstract finishedEventType: EventTypes;
    protected abstract sendDataEventType: EventTypes;
    constructor(url: string, bearerTokenProvider: () => string, options?: PopupOptions);
    abstract sendData(action: string, data: any): Promise<PopupResult>;
    protected abstract sendDataToPopup(action: string, data: any): void;
    isOpen(): boolean;
    close(): void;
    focus(): void;
    protected attachFinishedListener(resolve: (value?: any) => void, reject: (reason?: any) => void): () => void;
    protected createPopupMountedListener(correlationID: string): (message: MessageEvent) => void;
    protected createPopupClosedListener(reject: (reason?: any) => void): number;
    protected createFinishedListener(resolve: (value?: any) => void, reject: (reason?: any) => void): (message: MessageEvent) => void;
    /**
     * Process onPopupMountedQueue when popup is mounted
     */
    protected processPopupMountedQueue(): void;
}
export interface PopupOptions {
    useOverlay: boolean;
}
